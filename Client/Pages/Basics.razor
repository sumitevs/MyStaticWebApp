@page "/basics"

<div class="row">
    <br />
    <RadzenSteps Change=@OnChange>
        <Steps>
            <RadzenStepsItem >
                <RadzenCard Class="rz-my-12 rz-mx-auto" Style="max-width: 1020px">
                    <RadzenStack AlignItems="AlignItems.Center" Class="rz-mx-auto rz-my-12">
                        <RadzenImage Path="./images/basics001.jpg" Style="width: 100%;" />
                    </RadzenStack>
                    <RadzenCard class="rz-background-color-primary-lighter rz-shadow-0 rz-border-radius-0 rz-p-8" style="margin: 1rem calc(-1 * var(--rz-card-padding));">
                        <RadzenText TextStyle="TextStyle.Body1">
                            <mark>Class</mark>​ where we define a layout of an object. We specify how our objects should look and behave. 
                            So once we have a class, it is just a layout plan, or more commonly mentioned as a blueprint.​
                            For example the class House here.
                            <br />
                            <br />
                            Where as an <mark>Object</mark> is an instance of a class. It is a more real thing in some sense. It is not a plan, it is the thing in itself.​​
                            <br />
                            House JoeHouse = new House();​​
                            <br />
                            <br />
                            Now this might look to easy. From a plan to real house, in single line, no expense at all. ​
                            Actually there is a lot of expense behind the scene. JosHouse is taking up a lot of memory in you machine. ​
                            It will take up space for the living rooms, the dining rooms etc.​
                            The class declaration itself was taking hardly any memory. But once you initialize the class, or say create an instance of the class, it needs memory to exist. ​
                        </RadzenText>
                    </RadzenCard>
                </RadzenCard>
            </RadzenStepsItem>
            <RadzenStepsItem>
                <RadzenCard Class="rz-my-12 rz-mx-auto" Style="max-width: 1020px">
                    <RadzenStack AlignItems="AlignItems.Center" Class="rz-mx-auto rz-my-12">
                        <RadzenImage Path="./images/basics002.jpg" Style="width: 100%;" />
                    </RadzenStack>
                    <RadzenCard class="rz-background-color-primary-lighter rz-shadow-0 rz-border-radius-0 rz-p-8" style="margin: 1rem calc(-1 * var(--rz-card-padding));">
                        <RadzenText TextStyle="TextStyle.Body1">
                            Certain terms are confusing, like <mark>Class</mark>​, <mark>business object</mark>, <mark>entity</mark> etc.
                            <br/>
                            <br/>
                            We saw how a <mark>class</mark> and <mark>object</mark> is different.
                            <br/>
                            Now the term <mark>business object</mark> is used interchangeably with <mark>class</mark>. 
                            <mark>Business object</mark> is not an <mark>object</mark> in OOP terms. It means the same as a <mark>class</mark>.​
                            Anything from the real world that is significant enough to be represented as an class in our solution is referred an <mark>entity</mark>. 
                            So the word <mark>entity</mark> is used interchangeably with <mark>class</mark>.
                            <br/>
                            <br/>
                            <mark>OOP​ - Object Oriented Programming</mark> is your bible for programming.
                            <br/>
                            It is an approach to design and build applications that are:​
                            <br/>
                            -flexible
                            <br/>
                            -natural​
                            <br/>
                            -well-crafted​
                            <br/>
                            -testable​
                            <br/>
                            <br/>
                            By focusing on objects that interact cleanly with one another we make sure our design is good.​
                            This is an iterative process. We gone round and round over these sets, each time making our design better.
                        </RadzenText>
                    </RadzenCard>
                </RadzenCard>
            </RadzenStepsItem>
            <RadzenStepsItem>
                <RadzenCard Class="rz-my-12 rz-mx-auto" Style="max-width: 1020px">
                    <RadzenStack AlignItems="AlignItems.Center" Class="rz-mx-auto rz-my-12">
                        <RadzenImage Path="./images/basics003.jpg" Style="max-width: 100%;" />
                    </RadzenStack>
                    <RadzenCard class="rz-background-color-primary-lighter rz-shadow-0 rz-border-radius-0 rz-p-8" style="margin: 1rem calc(-1 * var(--rz-card-padding));">
                        <RadzenText TextStyle="TextStyle.Body1">
                            Let us start thinking towards our solution. 
                            <br/>
                            <br/>
                            The very first would be to understand the problem, or as the diagram calls it out, <mark>Analyse Requirement</mark>. Once we are clear on this, we can start to <mark>Extract the nouns</mark> from our requirement. These will help us come up with the entities required to solve our problem.​ And once we have the entities, we can <mark>Define features and behaviors</mark> of these entities. Because we want our entities to have certain characteristics and act in certain ways so that it all plays together to solve our problem. Let us look at each step for our given problem.
                        </RadzenText>
                    </RadzenCard>
                </RadzenCard>
            </RadzenStepsItem>
            <RadzenStepsItem>
                <RadzenCard Class="rz-my-12 rz-mx-auto" Style="max-width: 1020px">
                    <RadzenStack AlignItems="AlignItems.Center" Class="rz-mx-auto rz-my-12">
                        <RadzenImage Path="./images/basics004.jpg" Style="max-width: 100%;" />
                    </RadzenStack>
                    <RadzenCard class="rz-background-color-primary-lighter rz-shadow-0 rz-border-radius-0 rz-p-8" style="margin: 1rem calc(-1 * var(--rz-card-padding));">
                        <RadzenText TextStyle="TextStyle.Body1">
                            Here we have one liner request from our business owner. We need to analyse this, get missing information and re-word it to be more precise. Finally get it verified with the business owner. ​
                            <br/>
                            <mark>It’s a application to manage orders in a restaurant.​</mark>
                            <br/>
                            Who is the user of the application. Are there multiple users? What is the output expected? 
                            Do we need payment facility? The scope is endless, but for simplicity sake, we will stick to a bare minimum requirement.​ 
                            <br/>
                            <br/>
                            Using our application, a customer should be able to see the restaurant menu, select dishes in the menu to make an order. 
                            The application will calculate the total amount payable by the customer.
                        </RadzenText>
                    </RadzenCard>
                </RadzenCard>
            </RadzenStepsItem>
            <RadzenStepsItem>
                <RadzenCard Class="rz-my-12 rz-mx-auto" Style="max-width: 1020px">
                    <RadzenStack AlignItems="AlignItems.Center" Class="rz-mx-auto rz-my-12">
                        <RadzenImage Path="./images/basics005.jpg" Style="max-width: 100%;" />
                    </RadzenStack>
                    <RadzenCard class="rz-background-color-primary-lighter rz-shadow-0 rz-border-radius-0 rz-p-8" style="margin: 1rem calc(-1 * var(--rz-card-padding));">
                        <RadzenText TextStyle="TextStyle.Body1">
                            From the requirement, if we pull out the nouns, we will come up with these main entities. 
                            <br/>
                            <br/>
                            It starts with a <mark>Customer</mark>. There is always a customer to whom the application is serving.​
                            <br/>Then the first step is to display the <mark>Menu</mark>. So here Menu is an important entity and it consists of all the Dishes available in the restaurant. So <mark>Dish</mark> is also an import entity for us.
                            <br/>
                            <br/>
                            Then the customer is going to place an order eventually, so <mark>Order</mark> is also an entity to be considered. It will contain a number of order-items, and each <mark>order-item</mark> will be consisting of a dish and the quantity of it.​
                            <br/>
                            <br/>
                            Let me be very clear, this is not the only way to solve this problem, perhaps not even the best way. It is just one way of doing it. 
                        </RadzenText>
                    </RadzenCard>
                </RadzenCard>
            </RadzenStepsItem>
             <RadzenStepsItem>
                <RadzenCard Class="rz-my-12 rz-mx-auto" Style="max-width: 1020px">
                    <RadzenStack AlignItems="AlignItems.Center" Class="rz-mx-auto rz-my-12">
                        <RadzenImage Path="./images/basics006.jpg" Style="max-width: 100%;" />
                    </RadzenStack>
                    <RadzenCard class="rz-background-color-primary-lighter rz-shadow-0 rz-border-radius-0 rz-p-8" style="margin: 1rem calc(-1 * var(--rz-card-padding));">
                        <RadzenText TextStyle="TextStyle.Body1">
                            You can see what properties we want our entities to have. A customer needs to have a name, e-mail address and a phone number. Pretty basic right. Let us assume we have a database managing our data, so let us have some basic behaviours for our customer entity like, Save - it will save the customer into the database, Retrive - it will fetch customer data from the database and Validate - will check if the customer data is valid or not. These basic behviours are common to most entities. 
                            <br/>
                            <br/>
                            Save and Retrive are related to data access and should be ideally in a separe data access layer. We will move them eventually. But at a high level you need to understand the basic behivour we normally associate with any entities. 
                            <br/>
                            <br/>
                            Order class can hold multiple orderitems. And each orderitem will hold one dish and how much quantity it is ordered.​​
                            Notice we mentioned OrderItems in the class order. That means it will be a list(or array or collection) of OrderItem instances.​​
                            <br/>
                            <br/>
                            We also need to look at the effect of time on our model. With time, what can change, and will it cause our model to be inconsistent. ​
                            Imagine the price of a dish gets increased in future, so that change will reflect on an older Order because it is referred to through orderItem. ​
                            <br/>
                            So what you ordered for Rs100 two months ago, appears as Rs150 now, which is wrong. We could introduce a new property purchased price inside OrderItem which is independent of Dish to save the price of the dish at the time of ordering. Lets not bring in that complexity now.​
                            <br/>
                            <br/>
                            Next, Abstraction. Do you see it? It is once of the fundamental principles of OOP. It is a way of thinking more that a programming technique. ​
                            Lets look at our customer class. In reality a customer can have so many properties/features. Like a Joe is a customer, he has a wife, two kids, a car, brown hair and crooked nose. But we don’t really care of those properties in our use case. All we care is his name, email and phone number. So in practice, we have abstracted out the unwanted details and focused on the important details. And that is what abstraction is all about.
                        </RadzenText>
                    </RadzenCard>
                </RadzenCard>
            </RadzenStepsItem>
        </Steps>
    </RadzenSteps>
</div>
